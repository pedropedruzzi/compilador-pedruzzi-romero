Sintaxe da linguagem em Wirth


Idéia inicial:

programa = { declaracao_variavel | declaracao_funcao | declaracao_tipo | funcao } .
declaracao_variavel = tipo id [ "=" expressao ] { "," id [ "=" expressao ] } ";" .
tipo = ( "int" | "char" | "type" id ) [ "[" "]" ] { "[" constante "]" } .
prototipo_funcao = ( "int" | "char" | "void" ) id "(" [ tipo id { "," tipo id } ] ")" .
declaracao_funcao = prototipo_funcao ";" .
declaracao_tipo = "type" id "{" tipo id ";" { tipo id ";" } "}" ";" .
funcao = prototipo_funcao bloco .
bloco = "{" { declaracao_variavel } { comando } "}" .
comando = bloco | expressao ";" | if | while | for | "return" [ expressao ] ";" | "continue" ";" | "break" ";" | ";" .
if = "if" "(" expressao ")" comando [ "else" comando ] .
for = "for" "(" expressao ";" expressao ";" expressao ")" comando .
while = "while" "(" expressao ")" comando .


Expressão:
==========

lvalue = id { "[" expressao "]" | "." id } .
chamada_funcao = id "(" [ expressao { "," expressao } ] ")" .

expressao = { lvalue "=" } e1 .
e1 = e2 { op2 e2 } .
e2 = { op1 } e3 .
e3 = lvalue | chamada_funcao | constante | "(" expressao ")" .

op1 = "!" | "-" .
op2 = "+" | "-" | "*" | "/" | "%" | "==" | "<" | "<=" | ">" | ">=" | "&&" | "||".

simplificando:
expressao = { lvalue "=" } { op1 } e3 { op2 { op1 } e3 } .

juntando (sem tirar lvalue):
expressao = { lvalue "=" } { op1 } ( lvalue | id "(" [ expressao { "," expressao } ] ")" | constante | "(" expressao ")" ) { op2 { op1 } ( lvalue | id "(" [ expressao { "," expressao } ] ")" | constante | "(" expressao ")" ) } .

juntando tudo:
expressao = { id { "[" expressao "]" | "." id } "=" } { op1 } ( id { "[" expressao "]" | "." id } | id "(" [ expressao { "," expressao } ] ")" | constante | "(" expressao ")" ) { op2 { op1 } ( id { "[" expressao "]" | "." id } | id "(" [ expressao { "," expressao } ] ")" | constante | "(" expressao ")" ) } .




Simplificando
=============

1) substitui if, for e while em comando:

bloco = "{" { declaracao_variavel } { comando } "}" .
comando = bloco | expressao ";" | "if" "(" expressao ")" comando [ "else" comando ] | "while" "(" expressao ")" comando | "for" "(" expressao ";" expressao ";" expressao ")" comando | "return" [ expressao ] ";" | "continue" ";" | "break" ";" | ";" .

2) elimina bloco

funcao = prototipo_funcao "{" { declaracao_variavel } { comando } "}" .
comando = "{" { declaracao_variavel } { comando } "}" | expressao ";" | "if" "(" expressao ")" comando [ "else" comando ] | "while" "(" expressao ")" comando | "for" "(" expressao ";" expressao ";" expressao ")" comando | "return" [ expressao ] ";" | "continue" ";" | "break" ";" | ";" .

3) elimina prototipo_funcao, e junta declaracao_funcao com funcao

func = ( "int" | "char" | "void" ) id "(" [ tipo id { "," tipo id } ] ")" ( "{" { declaracao_variavel } { comando } "}" | ";" ) .

#################################
Resultado (esta é a sintaxe final! precisa jogar pra BNF, oq é bem facinho):

programa = { declaracao_variavel | declaracao_tipo | func } .
declaracao_variavel = tipo id [ "=" ( constante | string ) ] { "," id [ "=" ( constante | string ) ] } ";" .
tipo = ( "int" | "char" | "type" id ) [ "[" "]" ] { "[" constante "]" } .
declaracao_tipo = "type" id "{" tipo id ";" { tipo id ";" } "}" ";" .
func = ( "int" | "char" | "void" ) id "(" [ tipo id { "," tipo id } ] ")" ( "{" { declaracao_variavel } { comando } "}" | ";" ) .
comando = "{" { declaracao_variavel } { comando } "}" | expressao ";" | "if" "(" expressao ")" comando [ "else" comando ] | "while" "(" expressao ")" comando | "for" "(" expressao ";" expressao ";" expressao ")" comando | "return" [ expressao ] ";" | "continue" ";" | "break" ";" | ";" .
expressao = { lvalue "=" } { op1 } ( lvalue | id "(" [ expressao { "," expressao } ] ")" | constante | "(" expressao ")" ) { op2 { op1 } ( lvalue | id "(" [ expressao { "," expressao } ] ")" | constante | "(" expressao ")" ) } .
lvalue = id { "[" expressao "]" | "." id } .

Porém existe não-determinismo em 'programa' e 'expressao'.

Para resolver este problema, construiu-se a submáquina de cada um destes não-terminais, e eliminou-se o não-determinismo manualmente.

Neste processo, trechos de algumas outras submáquinas tiveram que ser fatorados para fora destas. Seguem as transformações feitas:




André.. A partir daqui eu vou te falar as etapas que fiz.

1) Peguei esta definição de expressão, coloquei os estados e gerei o automato (não-determinístico):
expressao = 0 { 2 lvalue 3 "=" 2 } 2 { 4 op1 5 } 4 e3 6 { 7 op2 8 { 9 op1 10 } 9 e3 11 } 7 . 1
Tirando as transições em vazio cheguei no autômato marcado com (1) nas folhas que eu vou te passar.

Porém ele continua não-deterministico pq no estado inicial, recebendo um identificador, não dá pra saber se chama a submáquina e3 ou a lvalue.

Para resolver isso eu fatorei o id do lvalue, com a seguinte transformação:
lvalue = id [ r_lvalue ] .

Construí a submáquina e3, com base na expressão:
e3 = id [ r_lvalue ] | id "(" [ expressao { "," expressao } ] ")" | constante | "(" expressao ")" .
pelo mesmo processo, tirando não-determinismo manualmente, cheguei na submaquina (2) das folhas.

Substitui esta submáquina e3 na máquina de expressao e cheguei no autômato (3). Note que eu ainda uso a e3 nela, pois só substituí a chamada que estava dando "conflito". Apesar disto, na implementação eu substituí e3 em todas as instancias. Em (4) está a submáquina que corresponde ao "resto" do lvalue.


2) Peguei a definição de programa:
programa = { declaracao_variavel | declaracao_tipo | func } .

fiz as seguintes substituições, fatorando os prefixos comuns:
declaracao_variavel = tipo id r_declaracao_variavel .
func = ( "int" | "char" | "void" ) id r_funcao .
declaracao_tipo = "type" id r_declaracao_tipo .

chegando em:
programa = { ( "int" | "char" | "type" id ) [ "[" "]" ] { "[" constante "]" } id r_declaracao_variavel | "type" id r_declaracao_tipo | ( "int" | "char" | "void" ) id r_funcao } .

construí o autômato a partir desta expressao, e tirei os não determinismosm, obtendo o autômato (5).


Acabaram os não determinismos!
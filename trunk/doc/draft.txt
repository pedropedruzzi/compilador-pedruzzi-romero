


Rascunhão da sintaxe:

    programa = { declaracao_variavel | declaracao_funcao | declaracao_tipo | funcao } .
    declaracao_variavel = tipo_basico [ "[" "]" ] { "[" num "]" } id [ "=" inicializacao ] { "," id [ "=" inicializacao ] } ";" .
    tipo_basico = "int" | "char" | "type" id .
    tipo_completo = tipo_basico { "[" "]" } .
    prototipo_funcao = ( tipo_completo | "void" ) id "(" [ tipo_completo id { "," tipo_completo id } ] ")" .
    declaracao_funcao = prototipo_funcao ";" .
    declaracao_tipo = "type" id "{" tipo_completo id ";" { tipo_completo id ";" } "}" ";" .
    funcao = prototipo_funcao bloco_comandos .
    bloco_comandos = "{" { declaracao_variavel } { comando } "}" .
    comando = bloco_comandos | expressao ";" | if | while | for | "return" expressao ";" | "continue" ";" | "break" ";" | ";" .
    expressao = atribuicao | id | chamada_funcao | ......... continua!
    atribuicao = id { "[" expressao "]" | "." id } "=" expressao .
    if = "if" "(" expressao ")" comando [ "else" comando ] .
    for = "for" "(" expressao ";" expressao ";" expressao ")" comando .
    while = "while" "(" expressao ")" comando .
    chamada_funcao = id "(" [ expressao { "," expressao } ] ")" .
		
	falta só concluir expressao!

Modelo de ponteiros (Java x C):
	-não tem alocação dinâmica
	-os ponteiros vão ficar disfarçados (sem o *, sem aritmética de ponteiro etc)
	-pode reapontar as coisas com em Java?
	-a sintaxe acima está assim:
		declaração de um objeto complexo:
		int[5][5][5] a;
		como estou pensando no modelo de vetor do Java, o tipo deste objeto é apenas int[][][]. Mas a declaração acima já aloca memória da mesma forma que em java seria:
		int[][][] a = new int[5][5][5];
		e se eu quiser declarar apenas uma referência desde tipo? como do java:
		int[][][] a;
		???
		
		os parametros de função e tipos de retorno já podem ser desta forma. O grande problema é que não quero ter ponteiros explicitos nem alocação dinâmica.
		Em C: distinção forte entre referências a tipos complexos estáticas e dinâmicas. exemplo: int a[5][5]; e int (*b)[5];
		Em Java: não há distinção pois tudo é ponteiro e dinâmico! mas como tem alocação dinâmica e gerenciamento de memória (coletor de lixo), beleza!
		No nosso caso: não temos alocação dinâmica e não queremos ver os ponteiros! E além disso não tem pilha (tudo é estático mesmo).
		
		Possíveis soluções:
		
		1) inventar um pseudo new estático. Ex.:
		// declaração de um ponteiro (que faz a = null;):
		int[][] a;
		// declaração de um vetor estático da memória:
		int[][] b = static int[5][5];
		// uma sintaxe mais coerente seria:
		static int[5][5] b;
		aí este b seria imutável, como em C.
		
		A mesma idéia teria que ser aplicada para struct's. Ex.:
		// declaração de um ponteiro (que faz a = null;):
		struct x a;
		// declaração de um registro estático da memória:
		static struct x b;
		b imutável, como em C.
		
		Este seria o jeito mais completo. Sem tirar poder da linguagem. Mas dá um certo trabalho. 
		
		2) Restringir: Toda declaração de variável de tipo complexo é uma alocação estática. Estas variáveis são imutáveis.
		Funções não retornam mais tipos complexos (por que não vai ter variável para atribuir!). Mas podem receber estas coisas como parâmetros (por referência), mas continuam imutáveis.
		A sintaxe fica:
		// declaração
		int[2][3] a;
		// ou inicializada:
		int[][3] a = { { 1, 2, 3}, {2, 3, 4} };
		// nas funções fica:
		void func(int[][] a, char[] b);
		
		Este jeito a princípio parece mais simples mas estou com algumas dúvidas.
		Se eu usar tipos complexos aninhados, ele vai querer alocar tudo de antemão. Não vai poder haver recursão de tipos, como numa lista ligada.
		Daria pra implementar uma lista ligada de inteiros. Ver abaixo.
		
		
		Romero optou pela opção 2! Tudo é estático. NADA de ponteiros!


Foi implementado uma engine de autômato de pilha estruturado com programação dinâmica.
Nos estados finais das submáquinas, pode-se adicionar uma ação semântica especial que retorna um objeto para a submáquina que fez a chamada.
Nas transições por classe de átomos (tokens) pode-de adicionar uma ou mais ações semânticas que recebem o átomo como argumento.
Nas chamadas de submáquinas pode-de adicionar uma ou mais ações semânticas que recebem o objeto de retorno da chamada como argumento.

-checagem de tipo:
	-inicializador
	-atribuição
	-chamada de função (argumentos)
	-retorno
	
	
dúvidas nos simbolos
====================


exemplo.. tenho uma variável:
int[10] a;


isso vai virar algo assim:
a		$ =20

se o nego quiser acessar um elemento, ex.: a[4].
o endereço obviamente é a + 4*sizeof(int)

como fica o código para este acesso?

imagina que seja a[i]

		LD i		; carrega o índice que está na memória
		*  CONST_2	; multiplica por sizeof(int) == 2
		+  a		; isso vai somar o valor na posição a... eu queria que somasse o endereço de a!
conclusão: a merda da mvn não tem instrução para acessar as coisas! tenho que guardar ponteiros! ou seja: se eu tenho int[] var; var vai ser um ponteiro para o vetor na memória:



__static_a		$	=20
a				K	__static_a

isto resolve também a passagem argumento para função.. passa sempre por valor.. e tipos complexos são ponteiros.. entao acabou.



